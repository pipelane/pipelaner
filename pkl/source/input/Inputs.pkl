@go.Package {name = "github.com/pipelane/pipelaner/gen/source/input" }
module pipelaner.source.inputs

import "package://pkg.pkl-lang.org/pkl-go/pkl.golang@0.8.1#/go.pkl"

abstract class Input {
  name: String
  fixed sourceName: String
  threads: Int = 1
  outputBufferSize: Int = 10
}

typealias SASLMechanism = "SCRAM-SHA-512" | "SCRAM-SHA-256"
typealias AutoOffsetReset = "earliest" | "latest"
typealias Strategy = "range" | "round-robin" | "cooperative-sticky"

class KafkaConsumer extends Input {
  fixed sourceName = "kafka"
  saslEnabled: Boolean(enableSaslRequiresMechanism)?

  hidden enableSaslRequiresMechanism = (_) ->
    if (saslMechanism == null)
      throw("Enable 'saslEnabled' requires set 'saslMechanism'")
    else true
  saslMechanism: SASLMechanism?

  saslUsername: String?
  saslPassword: String?
  brokers: String
  version: String?
  topics: Listing<String>
  schemaRegistry: String?
  autoCommitEnabled: Boolean? = false
  consumerGroupID: String
  // fetchMaxBytes > maxPartitionFetchBytes, можно добавить функцию проверки
  maxPartitionFetchBytes: DataSize = 50.mib
  fetchMaxBytes: DataSize = 10.mib
  autoOffsetReset: AutoOffsetReset = "earliest"
  balancerStrategy: Listing<Strategy>?
}

typealias ConnectionType = "unix"

class Pipelaner extends Input {
  fixed sourceName = "pipelaner"

  host: String?
  port: Int
  tls: Boolean(tlsEnabled)? = false

  hidden tlsEnabled = (_) ->
    if (keyFile == "" || certFile == "")
      throw("key and cert files required with enabled tls")
    else true
  certFile: String?
  keyFile: String?
  connectionType: ConnectionType?
  unixSocketPasth: String
}
